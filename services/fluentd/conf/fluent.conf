<system>
  @log_level debug
</system>

<source>
  @type tail
  path /logs/events.log
  pos_file /fluentd/log/events.log.pos
  tag simulator.event
  multiline_flush_interval 5s
  <parse>
    @type regexp
    expression /^(?<time>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d+) event=(?<event>\S+) user=(?<user>\S+) src_ip=(?<src_ip>\S+) dst_ip=(?<dst_ip>\S+).*$/
    time_key time
    time_format %Y-%m-%d %H:%M:%S.%N
  </parse>
</source>

<filter simulator.event>
  @type record_transformer
  enable_ruby true
  remove_keys event,user,src_ip,dst_ip
  <record>
    # OCSF Base Event Fields
    metadata_version "1.0.0"
    metadata_product_name "Traffic Simulator"
    metadata_vendor_name "Custom"
    metadata_product_version "1.0"
    metadata_profiles "security_control"
    
    # OCSF Class ID mapping based on event type
    class_uid ${case record["event"]; when /ssh_login_success|ssh_login_failure/; 3002; when /web_login_success|web_login_failure/; 3002; when /brute_force_attack/; 2004; when /sql_injection_attempt/; 2004; when /malware_detection/; 2001; when /data_exfiltration/; 4002; when /file_access/; 1001; else; 2004; end}
    
    # Activity ID based on success/failure
    activity_id ${case record["event"]; when /success/; 1; when /failure|attack|injection|malware|exfiltration/; 2; else; 99; end}
    
    # Severity mapping
    severity_id ${case record["event"]; when /success/; 1; when /failure/; 2; when /brute_force|injection/; 3; when /malware|exfiltration/; 4; else; 2; end}
    
    # Status mapping
    status_id ${case record["event"]; when /success/; 1; when /failure|attack|injection|malware|exfiltration/; 2; else; 99; end}
    
    # Actor (user) information
    actor_user_name ${record['user']}
    actor_user_type "User"
    actor_user_uid ${record['user']}
    
    # Source endpoint
    src_endpoint_ip ${record['src_ip']}
    src_endpoint_type "Unknown"
    
    # Destination endpoint
    dst_endpoint_ip ${record['dst_ip']}
    dst_endpoint_type "Unknown"
    
    # Event time - set both time and time_dt
    time ${time.to_i}
    time_dt ${time.utc.strftime('%Y-%m-%dT%H:%M:%S.%LZ')}
    
    # Message description
    message ${"Security event: " + record['event'] + " from " + record['user'] + " (" + record['src_ip'] + " -> " + record['dst_ip'] + ")"}
    
    # Category based on event type
    category_name ${case record["event"]; when /login/; "Identity & Access Management"; when /file/; "System Activity"; when /attack|injection|malware|exfiltration/; "Findings"; else; "Network Activity"; end}
    
    # Type name
    type_name ${case record["event"]; when /ssh_login/; "SSH Authentication"; when /web_login/; "Web Authentication"; when /brute_force/; "Brute Force Attack"; when /sql_injection/; "SQL Injection"; when /malware/; "Malware Detection"; when /data_exfiltration/; "Data Exfiltration"; when /file_access/; "File Access"; else; "Security Event"; end}
    
    # Store original event data for reference
    original_event_type ${record['event']}
    
    # OCSF product information
    ocsf_product_name "Traffic Simulator"
    ocsf_vendor_name "Custom"
    ocsf_version "1.0.0"
    
    # Flattened fields for easier querying
    user_name ${record['user']}
    src_ip ${record['src_ip']}
    dst_ip ${record['dst_ip']}
  </record>
</filter>

<match simulator.event>
  @type kafka2
  # kafka output environment vars
  brokers "#{ENV['KAFKA_BROKER']}"
  default_topic "#{ENV['KAFKA_EVENT_LOG_TOPIC']}"
  <format>
    @type json
  </format>
  <buffer>
    flush_interval 5s
    chunk_limit_size 1m
    flush_thread_count 2
  </buffer>
</match>
